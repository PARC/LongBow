#! /usr/bin/env python
# Copyright (c) 2014, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC)
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# * Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL XEROX OR PARC BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
# ################################################################################
# #
# # PATENT NOTICE
# #
# # This software is distributed under the BSD 2-clause License (see LICENSE
# # file).  This BSD License does not make any patent claims and as such, does
# # not act as a patent grant.  The purpose of this section is for each contributor
# # to define their intentions with respect to intellectual property.
# #
# # Each contributor to this source code is encouraged to state their patent
# # claims and licensing mechanisms for any contributions made. At the end of
# # this section contributors may each make their own statements.  Contributor's
# # claims and grants only apply to the pieces (source code, programs, text,
# # media, etc) that they have contributed directly to this software.
# #
# # There is no guarantee that this section is complete, up to date or accurate. It
# # is up to the contributors to maintain their portion of this section and up to
# # the user of the software to verify any claims herein.
# #
# # Do not remove this header notification.  The contents of this section must be
# # present in all distributions of the software.  You may only modify your own
# # intellectual property statements.  Please provide contact information.
# 
# - Palo Alto Research Center, Inc
# This software distribution does not grant any rights to patents owned by Palo
# Alto Research Center, Inc (PARC). Rights to these patents are available via
# various mechanisms. As of January 2016 PARC has committed to FRAND licensing any
# intellectual property used by its contributions to this software. You may
# contact PARC at cipo@parc.com for more information or visit http://www.ccnx.org
#
# @author Glenn Scott, Palo Alto Research Center (PARC)
# @copyright (c) 2014, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC).  All rights reserved.
import os
import subprocess
import re
import sys
import pprint
import FileUtil
import Language_C

class GCov:
    def __init__(self):
        return

def canonicalizeLines(lines):
    result = []
    accumulatedLine = ""
    for line in lines:
        line = line.strip()
        if len(line) == 0:
            if len(accumulatedLine.strip()) > 0:
                result.append(accumulatedLine.strip())
            accumulatedLine = ""
        elif "creating" in line:
            if len(accumulatedLine.strip()) > 0:
                result.append(accumulatedLine.strip())
            accumulatedLine = ""
            result.append(line)
        else:
            accumulatedLine = accumulatedLine + " " + line
    return result

def executeGCovCommand(testExecutableFileName):
    currentDirectory = os.getcwd()
    targetDirectory = os.path.dirname(os.path.abspath(testExecutableFileName))
    testExecutableBaseName = os.path.basename(testExecutableFileName)

    os.chdir(targetDirectory)
    objects = Language_C.findFiles("./", testExecutableBaseName+"*.o")
    if not objects:
        return
    objdir = os.path.dirname(objects[0])
    gcdas = Language_C.findFiles("./", testExecutableBaseName+"*.gcda")
    if not gcdas:
        return
    gcda = gcdas[0]
    gcnos = Language_C.findFiles("./", testExecutableBaseName+"*.gcno")
    if not gcnos:
        return
    gcno = gcnos[0]
    proc = subprocess.Popen(['gcov', '-af', '-o='+objdir, '-gcda='+gcda, '-gcno='+gcno, testExecutableBaseName], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    os.chdir(currentDirectory)

    inputLines = map(lambda line: line.strip(), proc.stdout)

    return canonicalizeLines(inputLines)

def parseFunctionLine(line):
    # Function 'TestFixture_Global_TearDown' Lines executed:71.43% of 7"
    search = re.search("Function '(.*)' Lines executed:(.*)% of (.*)", line, re.IGNORECASE)

    result = []
    if search:
        functionName = search.group(1)
        percentage = search.group(2)
        totalLines = search.group(3)
        result = { functionName : { "coverage" : float(percentage), "numberOfLines" : int(totalLines) } }

    return result

def parseFileLine(testExecutableDirectoryName, line):
    # File './../parc_Buffer.c' Lines executed:92.69% of 424
    search = re.search("File '(.*)' Lines executed:(.*)% of (.*)", line, re.IGNORECASE)

    result = { }
    if search:
        baseName = os.path.basename(search.group(1));
        fileName = os.path.abspath(testExecutableDirectoryName + "/" + baseName)
        percentage = search.group(2)
        totalLines = search.group(3)
        result = { fileName : { "coverage" : float(percentage), "totalLines" : int(totalLines) } }

    return result

def parseCreatingLine(testExecutableDirectoryName, line):
    search = re.search("(.*):creating '(.*)'", line, re.IGNORECASE)

    result = None
    if search:
        baseName = os.path.basename(search.group(1));
        fileName = os.path.abspath(testExecutableDirectoryName + "/" + baseName)
        baseName = os.path.basename(search.group(2));
        gcovFileName = os.path.abspath(testExecutableDirectoryName + "/" + baseName)

    result = { "fileName" : fileName, "gcovFileName" : gcovFileName, "gcovLines" : FileUtil.readFileLines(gcovFileName) }

    return result


def computeCoverageFromGCovLines(testExecutableDirectoryName, testExecutableFileName, lines):
    '''
    This produces a dictionary consisting of:

    'testedFiles' : dictionary containing as keys 'functions' and the name of a file that was tested

    The value of the key that is the name of a file that was tested is a dictionary containing the keys,
    'coverage', 'gcovFileName', and 'gcovLines'

    'coverage' is the percentage of code executed

    'testedFunctions' is a list containing lists consisting of the function name, the percent executed, and the number of lines in the function.
    '''
    testedFiles = { }
    testedFunctions = { }
    gcovFileNames = []
    for line in lines:
        if line.startswith("Function"):
            element = parseFunctionLine(line)
            testedFunctions.update(element)
        elif line.startswith("File"):
            element = parseFileLine(testExecutableDirectoryName, line)
            testedFiles.update(element)
        else:
            element = parseCreatingLine(testExecutableDirectoryName, line)
            if element != None:
                fileName = element["fileName"]
                del element["fileName"]
                testedFiles[fileName].update(element)
        pass

    result = { testExecutableFileName : { "testedFunctions" : testedFunctions, "testedFiles" : testedFiles } }

    return result


def noCoverage():
    result = { "testedFiles" : { }, "testedFunctions" : { } }
    return result

def getCoverage(testExecutableFileName):
    '''
    '''
    if testExecutableFileName == None:
        return None

    testExecutableFileName = os.path.abspath(testExecutableFileName)
    testExecutableDirectoryName = os.path.dirname(testExecutableFileName)
    gcovLines = executeGCovCommand(testExecutableFileName)

    return computeCoverageFromGCovLines(testExecutableDirectoryName, testExecutableFileName, gcovLines)


def selectGreaterCoverage(testedFileA, testedFileB):
    result = testedFileB
    if testedFileA["coverage"] >= testedFileB["coverage"]:
        result = testedFileA

    return result

def computeSummary(filesAndTests, newGCovResults):
    '''
    First, for each target file named in the gcov results, find the corresponding testedFile and report the maximum coverage.

    If the target file is not in any of the testedFiles

    { targetFileName : { "coverage": percent, "veracity" : "direct" / "indirect" } }
    '''

    newGCovResults = filter(lambda entry: entry != None, newGCovResults)

    result = dict()
    for entry in newGCovResults:
        for testExecutableName in entry:
            testExecutableCSourceName = Language_C.Module(testExecutableName).getCSourceName()

            for testedFileName in entry[testExecutableName]["testedFiles"]:
                testedFile = entry[testExecutableName]["testedFiles"][testedFileName]

                if Language_C.Module(testedFileName).getTestExecutableName() == os.path.basename(testExecutableName):
                    result[testedFileName] = testedFile
                    result[testedFileName]["direct"] = "direct"
                elif testedFileName in result:
                    bestCoverage = selectGreaterCoverage(testedFile, result[testedFileName])
                    if result[testedFileName] != bestCoverage:
                        result[testedFileName] = bestCoverage
                        result[testedFileName]["direct"] = "indirect"
                else:
                    result[testedFileName] = testedFile
                    result[testedFileName]["direct"] = "indirect"

    return result

def computeAverage(filesAndTests, gcovResults):
    summary = computeSuperSummary(filesAndTests, gcovResults)

    filesToAverage = removeTestSourceFiles(summary)

    score = 0.0

    if len(filesToAverage) > 0:
        sum = reduce(lambda x, y: x + y, map(lambda entry: summary[entry]["coverage"], filesToAverage))
        score = sum / float(len(filesToAverage))

    return score


if __name__ == '__main__':
    pp = pprint.PrettyPrinter(indent=4, width=132)
    if True:
        gcovResult = getCoverage("/Users/gscott/Documents/workspace/Distillery/Libparc/parc/algol/test/test_parc_JSON")
    else:
        lines = sys.stdin.readlines()
        lines = canonicalizeLines(lines)
        pp.pprint(lines)

        gcovResult = computeCoverageFromGCovLines("/Users/gscott/Documents/workspace/Distillery/Libparc/parc/algol/test/", lines)

    pp.pprint(gcovResult)
