#! /usr/bin/env python
# Copyright (c) 2015, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC)
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL XEROX OR PARC BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# ################################################################################
# #
# # PATENT NOTICE
# #
# # This software is distributed under the BSD 2-clause License (see LICENSE
# # file).  This BSD License does not make any patent claims and as such, does
# # not act as a patent grant.  The purpose of this section is for each contributor
# # to define their intentions with respect to intellectual property.
# #
# # Each contributor to this source code is encouraged to state their patent
# # claims and licensing mechanisms for any contributions made. At the end of
# # this section contributors may each make their own statements.  Contributor's
# # claims and grants only apply to the pieces (source code, programs, text,
# # media, etc) that they have contributed directly to this software.
# #
# # There is no guarantee that this section is complete, up to date or accurate. It
# # is up to the contributors to maintain their portion of this section and up to
# # the user of the software to verify any claims herein.
# #
# # Do not remove this header notification.  The contents of this section must be
# # present in all distributions of the software.  You may only modify your own
# # intellectual property statements.  Please provide contact information.
#
# - Palo Alto Research Center, Inc
# This software distribution does not grant any rights to patents owned by Palo
# Alto Research Center, Inc (PARC). Rights to these patents are available via
# various mechanisms. As of January 2016 PARC has committed to FRAND licensing any
# intellectual property used by its contributions to this software. You may
# contact PARC at cipo@parc.com for more information or visit http://www.ccnx.org
#
# @author Glenn Scott, Palo Alto Research Center (PARC)
# @copyright (c) 2015, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC).  All rights reserved.
import sys
import os
import re
import subprocess
import difflib
import csv
# import argparse
import pprint
# sys.path.append("${INSTALL_PYTHON_DIR}")
# sys.path.append("${DEPENDENCY_PYTHON_DIR}")
# sys.path.append("../site-packages/longbow/")
import LongBow
import GCov
import GCovSummary
import FileUtil
import ANSITerm
import Language_C

def checkTestExecutable(executableFileName):
    result = False

    if not os.path.exists(executableFileName):
        return result

    path = os.path.dirname(executableFileName)
    pattern = os.path.basename(executableFileName)+'*.gcda'
    if not Language_C.findFiles(path, pattern):
        return result

    pattern = os.path.basename(executableFileName)+'*.gcno'
    if not Language_C.findFiles(path, pattern):
        return result

    result = True
    return result

def findTestExecutable(fileName, hints=[]):
    '''
Given a file name, look in the canonical places for a corresponding LongBow test file.
    '''
    directoryName = os.path.dirname(fileName)
    if len(directoryName) == 0:
        directoryName = "."

    file = Language_C.Module(fileName)

    possibleTestFiles = list()
    for hint in hints:
        possibleTestFiles.append(hint + "/" + file.getExecutableName())
        possibleTestFiles.append(hint + "/" + file.getTestExecutableName())
    possibleTestFiles.append(directoryName + "/" + file.getExecutableName())
    possibleTestFiles.append(directoryName + "/" + file.getTestExecutableName())
    possibleTestFiles.append(directoryName + "/test/" + file.getTestExecutableName())

    result = None
    for possibleTestFile in possibleTestFiles:
        if checkTestExecutable(possibleTestFile) == True:
            result = os.path.abspath(possibleTestFile)
            break

    return result


def textSummary(args, filesAndTests, gCovResults, prefix=""):

    summary = GCov.computeSummary(filesAndTests, gCovResults)

    if not args.includeTestSources:
        summary = GCovSummary.removeTestSourceFiles(summary)

    if len(summary) == 0:
        return

    if args.explain:
        pp = pprint.PrettyPrinter(indent=2, width=150)
        pp.pprint(summary)

    maximumFileLength = max(map(lambda entry: len(entry), summary))

    format = "%s%-" + str(maximumFileLength) + "s %6s"
    print format % (prefix, "File Path", "Score")

    format = "%s%-" + str(maximumFileLength) + "s %6.2f"
    for testedFile in sorted(summary.keys()):
        string = format % (prefix, testedFile, summary[testedFile]["coverage"])
        if summary[testedFile]["direct"] == "indirect":
            ANSITerm.printColorized("magenta", string)
        else:
            LongBow.scorePrinter(eval(args.distribution), summary[testedFile]["coverage"], string)

    return


def textAverage(args, filesAndTests, gcovResults):
    summary = GCov.computeSummary(filesAndTests, gcovResults)

    if not args.includeTestSources:
        summary = GCovSummary.removeTestSourceFiles(summary)

    score = GCovSummary.averageCoverage(summary)

    LongBow.scorePrinter(eval(args.distribution), score, "%.2f" % (score))
    return score


def csvSummary(args, filesAndTests, gCovResults):
    summary = GCov.computeSummary(filesAndTests, gCovResults)

    if not args.includeTestSources:
        summary = GCovSummary.removeTestSourceFiles(summary)

    if len(summary) > 0:
        for testedFile in sorted(summary.keys()):
            outputString = "%s,%.2f" % (testedFile, summary[testedFile]["coverage"])
            LongBow.scorePrinter(eval(args.distribution), summary[testedFile]["coverage"], outputString)

    return


def csvAverage(args, filesAndTests, gcovResults):
    summary = GCov.computeSummary(filesAndTests, gcovResults)

    if not args.includeTestSources:
        summary = GCovSummary.removeTestSourceFiles(summary)

    score = GCovSummary.averageCoverage(summary)

    LongBow.scorePrinter(eval(args.distribution), score, "%.2f" % (score))
    return


def textVisualDisplayGcovLine(line):
    token = line.split(":", 2)
    if len(token) == 3:
        if token[0] == "#####":
            print ANSITerm.colorize("red", token[1] + " " + token[2])
        elif token[0] == "$$$$$":
            print ANSITerm.colorize("yellow", token[1] + " " + token[2])
        else:
            print ANSITerm.colorize("green", token[1] + " " + token[2])

    return


def textVisual(args, filesAndTests, gcovResults):

    summary = GCov.computeSummary(filesAndTests, gcovResults)
    if args.explain:
        pp = pprint.PrettyPrinter(indent=2, width=150)
        pp.pprint(summary)
        pp.pprint(filesAndTests)

    for entry in filesAndTests:
        print entry[0]
        try:
            gcovLines = summary[entry[0]]["gcovLines"]
            map(lambda line: textVisualDisplayGcovLine(line.strip()), gcovLines)
        except KeyError:
            print >> sys.stderr, "No coverage information for", entry[0]

    return


def displaySummary(args, filesAndTests, newGCovResults):
    if args.output == "text":
        textSummary(args, filesAndTests, newGCovResults)
    elif args.output == "csv":
        csvSummary(args, filesAndTests, newGCovResults)
    else:
        print >> sys.stderr, "Unsupported output type"
    return


def displayAverage(args, filesAndTests, gcovResults):
    if args.output == "text":
        textAverage(args, filesAndTests, gcovResults)
    elif args.output == "csv":
        csvAverage(args, filesAndTests, gcovResults)
    else:
        print >> sys.stderr, "Unsupported output type"
    return


def explain(args, filesAndTests, gcovResults):

    pp = pprint.PrettyPrinter(indent=2, width=150)
    pp.pprint(gcovResults)

    return

def getFilesAndTests(fileNames, testDirs=[]):
    namesAndPaths = map(lambda fileName: [fileName, os.path.abspath(fileName)], fileNames)
    filesAndTests = map(lambda nameAndPath: [ nameAndPath[0], findTestExecutable(nameAndPath[1], testDirs) ], namesAndPaths)
    return filesAndTests


def gradeAndPrint(targets, testDirs=[], problemsOnly=False, prefix=""):
    filesAndTests = getFilesAndTests(targets, testDirs)
    newGCovResults = map(lambda fileAndTestFile: GCov.getCoverage(fileAndTestFile[1]), filesAndTests)

    summarys = GCov.computeSummary(filesAndTests, newGCovResults)
    if len(summarys) < 1:
        print "%sNo GCov Results - Please be sure to run 'make check' first" % prefix
        return False
    summarys = GCovSummary.removeTestSourceFiles(summarys)

    paths = summarys.keys()
    if problemsOnly:
        paths = filter(lambda key: summarys[key]["coverage"] < 100, paths)

    distribution=[99,90]
    maximumFileLength = max(map(lambda entry: len(os.path.relpath(entry)), paths))
    format = "%s%-" + str(maximumFileLength) + "s %6s"
    print format % (prefix, "File Path", "Score")
    format = "%s%-" + str(maximumFileLength) + "s %6.2f"
    for path in sorted(paths):
        string = format % (prefix, os.path.relpath(path), summarys[path]["coverage"])
        LongBow.scorePrinter(distribution, summarys[path]["coverage"], string)

    return True

def commandLineMain(args, fileNames, testDir=""):

    testDirs = []
    if testDir:
        testDirs.append(testDir)
    fileNames = map(lambda fileName: os.path.abspath(fileName), fileNames)
    filesAndTests = map(lambda fileName: [fileName, findTestExecutable(fileName, testDirs)], fileNames)

    filesWithNoTest = filter(lambda fileAndTest: fileAndTest[1] == None, filesAndTests)
    if len(filesWithNoTest) != 0:
        outputFormat = "%s has no corresponding test executable or coverage data.\n"
        map(lambda filesAndTests: sys.stderr.write(outputFormat % (filesAndTests[0])), filesWithNoTest)

    gCovResults = map(lambda fileAndTestFile: GCov.getCoverage(fileAndTestFile[1]), filesAndTests)

    if args.summary is True:
        displaySummary(args, filesAndTests, gCovResults)
    elif args.average is True:
        displayAverage(args, filesAndTests, gCovResults)
    elif args.visual is True:
        textVisual(args, filesAndTests, gCovResults)
    elif args.explain is True:
        explain(args, filesAndTests, gCovResults)

    return True
